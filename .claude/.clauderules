# Claude Code Rules for Financial Tracker Project

## Code Documentation Standards

### Docstrings: Primary Documentation Method
- **REQUIRED**: Every function, class, module, and component MUST have comprehensive docstrings
- Use language-appropriate docstring formats:
  - Python: `"""Triple-quoted docstrings"""`
  - JavaScript/TypeScript: `/** JSDoc comments */`
  - Include: purpose, parameters, return values, exceptions, and usage examples when helpful

### Inline Comments: Strictly Prohibited (with exceptions)
- **FORBIDDEN**: Do NOT use inline comments (`#`, `//`) to explain what code does
- Code must be self-documenting through:
  - Descriptive variable and function names
  - Clear, single-responsibility functions
  - Logical code organization
  - Proper abstraction layers

- **PERMITTED ONLY**: Inline comments are allowed in these specific cases:
  1. **Standard Markers**: `TODO:`, `FIXME:`, `NOTE:`, `HACK:`, `WARNING:`
  2. **"Why" Explanations**: Clarify non-obvious reasoning, business rules, or optimization choices
     - Explain WHY the code exists, NOT WHAT it does
     - Reference tickets, issues, or external documentation when applicable

### Examples

**FORBIDDEN (explaining "what"):**
```python
# Loop through expenses
for expense in expenses:
    # Add to total
    total += expense.amount
```

**REQUIRED (docstring):**
```python
def calculate_total_expenses(expenses: list[Expense]) -> Decimal:
    """
    Calculate the sum of all expense amounts.

    Args:
        expenses: List of Expense objects to sum

    Returns:
        Total amount as Decimal
    """
    return sum(expense.amount for expense in expenses)
```

**PERMITTED (explaining "why"):**
```python
# HACK: Must reverse process to avoid race condition in legacy API (ticket #1234)
for item in reversed(items):
    process(item)

# NOTE: Transition cycle is 44 days to accommodate billing schedule change
if start_date == CYCLE_CHANGE_DATE:
    end_date = CYCLE_TRANSITION_END_DATE
```

## Software Engineering Best Practices

### Code Quality Principles

1. **Single Responsibility Principle (SRP)**
   - Each function/class/module should have one clear purpose
   - If it requires "and" to describe, it's doing too much
   - Split complex functions into smaller, focused units

2. **DRY (Don't Repeat Yourself)**
   - Extract repeated logic into reusable functions/modules
   - Create utility functions for common operations
   - Use configuration files for repeated values

3. **Naming Conventions**
   - Use descriptive, unambiguous names
   - Prefer clarity over brevity: `calculateMonthlyTotal()` over `calcMT()`
   - Follow language conventions:
     - Python: `snake_case` for functions/variables, `PascalCase` for classes
     - JavaScript: `camelCase` for functions/variables, `PascalCase` for classes/components

4. **Function Design**
   - Keep functions small (ideally under 20 lines)
   - Limit parameters (max 3-4; use objects for more)
   - Return early to avoid deep nesting
   - Avoid side effects when possible (pure functions preferred)

5. **Error Handling**
   - Always handle potential errors explicitly
   - Use try-catch blocks appropriately
   - Provide meaningful error messages
   - Log errors with context for debugging

6. **Type Safety**
   - Use type hints in Python (typing module)
   - Use JSDoc or TypeScript for JavaScript
   - Validate inputs at function boundaries
   - Avoid implicit type coercion

### Architecture Principles

1. **Separation of Concerns**
   - Business logic (core/) separate from presentation (dashboard, bot)
   - Database operations isolated in repository layer
   - API routes separate from business logic
   - Frontend components separate from data fetching

2. **Dependency Injection**
   - Pass dependencies as parameters, not hardcoded imports
   - Use configuration objects for settings
   - Enable testing by allowing mock implementations

3. **Modular Design**
   - Group related functionality into modules
   - Define clear interfaces between modules
   - Minimize coupling, maximize cohesion
   - Each module should be independently testable

4. **Layered Architecture**
   - Presentation Layer: UI components, API routes
   - Business Logic Layer: Core domain logic
   - Data Access Layer: Repository pattern for database
   - Infrastructure Layer: External services (Telegram API, database connections)

5. **API Design**
   - RESTful conventions (GET, POST, PUT, DELETE)
   - Consistent URL patterns (`/api/resource`)
   - Proper HTTP status codes
   - Versioning strategy for breaking changes
   - Comprehensive error responses with details

### Infrastructure and DevOps

1. **Environment Configuration**
   - NEVER hardcode credentials or secrets
   - Use environment variables for all configuration
   - Provide `.env.example` files with required variables
   - Validate environment on startup

2. **Docker Best Practices**
   - Multi-stage builds for optimized images
   - Specific version tags (avoid `latest`)
   - Minimal base images (Alpine when possible)
   - Proper layer caching for faster builds
   - Health checks for all services

3. **Database Management**
   - Use connection pooling for performance
   - Prepared statements to prevent SQL injection
   - Migrations for schema changes (not manual SQL)
   - Indexes on frequently queried columns
   - Backup strategy documented

4. **Logging and Monitoring**
   - Structured logging (JSON format preferred)
   - Log levels: DEBUG, INFO, WARNING, ERROR
   - Include context: timestamp, service, request ID
   - Never log sensitive data (passwords, tokens)

5. **Testing Strategy**
   - Unit tests for business logic
   - Integration tests for database operations
   - End-to-end tests for critical flows
   - Test coverage minimum 70% for core logic
   - Run tests in CI/CD pipeline

### Security Practices

1. **Input Validation**
   - Validate all user inputs (type, format, range)
   - Sanitize inputs before database operations
   - Use parameterized queries (prevent SQL injection)
   - Limit input size to prevent DoS

2. **Authentication & Authorization**
   - Verify user identity for all protected operations
   - Check permissions before allowing actions
   - Use secure token storage (environment variables)
   - Implement rate limiting for API endpoints

3. **Data Protection**
   - Encrypt sensitive data at rest
   - Use HTTPS for all external communications
   - Implement CORS properly (restrict origins)
   - Never expose internal errors to clients

4. **Dependency Management**
   - Keep dependencies up to date
   - Use lock files (package-lock.json, poetry.lock)
   - Scan for vulnerabilities regularly
   - Minimize dependency count

### Performance Optimization

1. **Database Queries**
   - Use indexes for WHERE, JOIN, ORDER BY columns
   - Limit result sets (pagination)
   - Avoid N+1 query problems
   - Use CTEs for complex queries
   - Monitor slow queries and optimize

2. **API Performance**
   - Implement caching where appropriate
   - Use compression (gzip)
   - Batch requests when possible
   - Implement pagination for large datasets
   - Parallel processing for independent operations

3. **Frontend Performance**
   - Lazy load components/routes
   - Optimize images (WebP format, compression)
   - Minimize bundle size (code splitting)
   - Use React.memo for expensive renders
   - Debounce user inputs (search, filters)

### Code Review Checklist

Before committing code, verify:
- [ ] All functions have comprehensive docstrings
- [ ] No unnecessary inline comments explaining "what"
- [ ] Variable and function names are descriptive
- [ ] Functions follow SRP (single responsibility)
- [ ] No hardcoded values (use constants/config)
- [ ] Error handling implemented
- [ ] No commented-out code (remove it)
- [ ] Code formatted consistently (Prettier/Ruff)
- [ ] Tests added/updated for new functionality
- [ ] No security vulnerabilities introduced
- [ ] Performance implications considered
- [ ] Documentation updated if public API changed

## Project-Specific Rules

### Billing Cycle Logic
- ALWAYS preserve transition cycle logic (Oct 4 - Nov 16, 2025)
- NEVER retroactively change historical data
- Update tests when modifying cycle calculations
- Document cycle changes in CLAUDE.md

### Installment Handling
- Use recursive CTEs for installment distribution
- Prorate amounts across billing cycles correctly
- Handle transition cycle for installments spanning the change

### Telegram Bot
- Validate ALL user inputs before processing
- Check ALLOWED_USER_ID for every command
- Provide helpful error messages in Portuguese
- Log all expense entries for audit trail

### Frontend Development
- Use custom hooks for shared state/logic
- Keep components small and focused (< 150 lines)
- Implement proper loading and error states
- Ensure responsive design (mobile-first)
- Use semantic HTML and accessibility attributes

### API Development
- All endpoints must validate query parameters
- Return consistent error response format
- Include proper CORS headers
- Log all requests with response time
- Document endpoints in API README

## Enforcement

These rules are MANDATORY. Code that violates these principles should be:
1. Flagged during code review
2. Refactored before merging
3. Added to technical debt backlog if urgent

When uncertain about a pattern, prioritize:
1. Readability over cleverness
2. Maintainability over performance (unless profiled bottleneck)
3. Explicitness over implicitness
4. Consistency with existing codebase
